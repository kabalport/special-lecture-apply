# 끄적끄적할용도로 만든 생각정리 파일
- fixture만들어서 성공객체,실패객체들 만들어서 테스트객체 재사용하게 리팩토링하기
- 다이어그램그리기&그리고나서그림백업&피드백&머메이드코드로정리
  - 유스케이스다이어그램
  - 클래스다이어그램
  - 시퀀스다이어그램
  - 스프링부트아키텍처다이어그램(controller,sevice,repo,domain)

# 리팩토링
- 테이블의 아이디의 커서가 잘 작동하는지테스트
- 공통코드정의 enum 해야되는지 고민좀해보기
- 깃플로우 해봐야되나... 맨날 내가 하는거 깃패치, 깃풀, 그 브랜치 작업 끝,여기서 머지하거나에서 거기서 끝이거나 이상태로 쭉 갔음.
- 로깅컨벤션에 맞게 리팩토링하기
- 제네릭,Optional,Stream 써보기-공부했으면 써야되지만 잘 안쓰게되는 3가지임
- 전체적인 메서드들 리팩토링하기
- Spring REST Docs api명세서 사용해보기
  [https://helloworld.kurly.com/blog/spring-rest-docs-guide/]
[공부해서 정리하기]
- synchronized
- ConcurrentHashMap
- RentrantLock
  
# 끄적끄적
비즈니스 로직 최적화
충전 및 사용 로직을 비롯해 동시성이 요구되는 작업들에 대해
비즈니스 로직을 최적화하여 동시에 처리되는 요청의 수를 줄일 수 있는 방법을 고려
사용자별 일일 포인트 충전 한도를 설정하기
과도한 요청에 대한 제한두기

# Todo
- 테스트할때 100건도 병렬처리 느린거보고 syncronize 존나 편한데 이거 좋은방법아닌것같음
- 동시성해결고민하기
# 동시성해결고민 생각들
- 사용자별로 Lock으로 관리한다.
- 사용자아이디별로 동시성을 관리하기 위해 현재 충전중인 사용자아이디로 키를 하는 ConcurrentHashMap(동시에 접근이 가능한 자료구조)에 Lock 객체를 저장한다
- 해당 사용자에 대한 작업을 수행할 때만 Lock을 거는 방법을 고려한다.
# 동시성해결고민 생각들2
- 요청 대기열 관리: 각 사용자 ID별로 요청을 관리할 수 있는 대기열을 구현, Java에서는 ConcurrentLinkedQueue 같은 스레드 안전한 큐를 사용하여 각 사용자 ID에 대한 요청을 관리할 수 있습니다.
  private final Map<Long, Queue<PointRequest>> requestQueues = new ConcurrentHashMap<>();
- 요청 처리 스케줄러: 별도의 스레드 또는 스레드 풀을 사용하여 대기열에서 요청을 순차적으로 처리하는 스케줄러를 구현 이 스케줄러는 대기열에서 요청을 꺼내 실제 작업을 수행하고 결과 처리
- 우선순위 부여: 필요한 경우, 요청에 우선순위를 부여할 수 있습니다. Java의 PriorityBlockingQueue를 사용하여 우선순위에 따라 요청을 관리
# 일일 포인트 충전한도를 설정해서 과도한 요청제한두기
- 1인당 충전은 하루에 10번
- 동시에 할수 있는 요청은 20개



